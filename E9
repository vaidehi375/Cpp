
#include <iostream>
#include <vector>
using namespace std;

class Graph {
    int numCities;
    vector<vector<int>> adjMatrix; // 2D vector for adjacency matrix
    vector<bool> visited;          // To keep track of visited cities

public:
    Graph(int n) {
        numCities = n;
        adjMatrix.resize(n, vector<int>(n, 0)); // initialize matrix with 0
        visited.resize(n, false);
    }

    void addEdge(int u, int v, int cost) {
        adjMatrix[u][v] = cost;
        adjMatrix[v][u] = cost; // because itâ€™s undirected (Aâ†”B)
    }

    void displayMatrix() {
        cout << "\nAdjacency Matrix:\n";
        for (int i = 0; i < numCities; i++) {
            for (int j = 0; j < numCities; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }

    void DFS(int city) {
        visited[city] = true;
        for (int i = 0; i < numCities; i++) {
            if (adjMatrix[city][i] != 0 && !visited[i]) {
                DFS(i);
            }
        }
    }

    void checkConnected() {
        DFS(0); // start from city 0 (first city)
        for (int i = 0; i < numCities; i++) {
            if (!visited[i]) {
                cout << "\nGraph is NOT Connected âŒ" << endl;
                return;
            }
        }
        cout << "\nGraph is Connected âœ…" << endl;
    }
};

int main() {
    int n;
    cout << "Enter number of cities: ";
    cin >> n;

    Graph g(n);
    int e;
    cout << "Enter number of flight paths: ";
    cin >> e;

    cout << "Enter edges (City1 City2 Cost):\n";
    for (int i = 0; i < e; i++) {
        int u, v, cost;
        cin >> u >> v >> cost;
        g.addEdge(u, v, cost);
    }

    g.displayMatrix();
    g.checkConnected();

    return 0;
}
