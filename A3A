#include <iostream>
using namespace std;

#define SIZE 10  // size of hash table

class HashTable {
    int keys[SIZE];      // array for storing keys (telephone numbers or IDs)
    string names[SIZE];  // array for storing client names

public:
    HashTable() {
        for (int i = 0; i < SIZE; i++) {
            keys[i] = -1;  // -1 means empty
            names[i] = "";
        }
    }

    // Hash function
    int hashFunction(int key) {
        return key % SIZE;  // gives index based on key
    }

    // Insert client info
    void insert(int key, string name) {
        int index = hashFunction(key);

        // Linear probing for collision
        while (keys[index] != -1) {
            index = (index + 1) % SIZE;  // move to next slot
        }

        keys[index] = key;
        names[index] = name;
    }

    // Search client info
    void search(int key) {
        int index = hashFunction(key);
        int startIndex = index;

        while (keys[index] != -1) {
            if (keys[index] == key) {
                cout << "Client found: " << names[index] << " (Phone No: " << key << ")\n";
                return;
            }
            index = (index + 1) % SIZE;
            if (index == startIndex) break;  // if we come back to start, stop
        }

        cout << "Client not found!\n";
    }

    // Display all data
    void display() {
        cout << "\nHash Table:\n";
        for (int i = 0; i < SIZE; i++) {
            if (keys[i] != -1)
                cout << i << " --> " << names[i] << " (" << keys[i] << ")\n";
            else
                cout << i << " --> [empty]\n";
        }
    }
};

int main() {
    HashTable ht;
    int choice, key;
    string name;

    do {
        cout << "\n--- Telephone Book Menu ---\n";
        cout << "1. Insert client\n2. Search client\n3. Display hash table\n4. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter client name: ";
                cin >> name;
                cout << "Enter telephone number: ";
                cin >> key;
                ht.insert(key, name);
                break;

            case 2:
                cout << "Enter telephone number to search: ";
                cin >> key;
                ht.search(key);
                break;

            case 3:
                ht.display();
                break;

            case 4:
                cout << "Exiting...\n";
                break;

            default:
                cout << "Invalid choice!\n";
        }
    } while (choice != 4);

    return 0;
}


} while (choice != 4); 

return 0; 

}





1 linear
●	If collision occurs at index, check index+1, index+2, ..., until an empty slot is found.
●	Formula: h(k, i) = (h(k) + i) % table_size
2. Quadratic Probing:
●	Probe sequence uses square increments to reduce clustering.
●	Formula: h(k, i) = (h(k) + c1·i + c2·i²) % table_size
 (Commonly, c1 = c2 = 1)
3. Double Hashing:
●	Uses two hash functions to compute the probe sequence
●	Formula: h(k, i) = (h1(k) + i × h2(k)) % table_size

●	Example:
 h1(k) = k % table_size
 h2(k) = R - (k % R) where R < table_size

Use Case: Telephone Book
Store (Key = Client Name or ID, Value = Phone Number)



Start

Input the total number of clients N.

Initialize a hash table of size SIZE (preferably greater than or equal to N).

Set all hash table positions as empty (e.g., key = -1 or name = " ").

Insertion Operation:

For each client:

Input telephone number key and client name name.

Compute hash index:
index = key % SIZE

If that position is empty:
→ Store key and name at index.

Else (collision occurs):
→ Use Linear Probing:

Increment index: index = (index + 1) % SIZE

Repeat until an empty position is found.

Insert the key and name there.

Search Operation:

Input the telephone number key to search.

Compute hash index:
index = key % SIZE

Repeat while that position is not empty:

If hashTable[index].key == key then
→ Print “Client Found” and display name.
→ Stop.

Else
→ Move to next index: index = (index + 1) % SIZE

If an empty position is reached without finding the key:
→ Print “Client not found.”

Display Operation (Optional):

Traverse the hash table and print all non-empty entries (index, name, telephone number).

Stop
