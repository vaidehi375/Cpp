
#include <iostream>
using namespace std;

#define SIZE 10  // size of hash table

class HashTable {
    long long keys[SIZE];      // array for storing telephone numbers (keys)
    string names[SIZE];        // array for storing client names

public:
    HashTable() {
        for (int i = 0; i < SIZE; i++) {
            keys[i] = -1;  // -1 means empty
            names[i] = "";
        }
    }

    // Primary hash function
    int hash1(long long key) {
        return key % SIZE;
    }

    // Secondary hash function (for double hashing)
    int hash2(long long key) {
        return 7 - (key % 7);  // 7 is a prime smaller than SIZE
    }

    // Insert client info using Double Hashing
    void insert(long long key, string name) {
        int index = hash1(key);
        int step = hash2(key);

        int i = 0;
        int newIndex;

        while (true) {
            newIndex = (index + i * step) % SIZE;

            // Empty slot found â†’ insert record
            if (keys[newIndex] == -1) {
                keys[newIndex] = key;
                names[newIndex] = name;
                cout << "Record inserted successfully at index " << newIndex << "\n";
                return;
            }

            // If key already exists â†’ update record
            if (keys[newIndex] == key) {
                names[newIndex] = name;
                cout << "Record updated at index " << newIndex << "\n";
                return;
            }

            i++;
            if (i == SIZE) {
                cout << "Hash table full! Cannot insert new record.\n";
                return;
            }
        }
    }

    // Search client info using double hashing
    void search(long long key) {
        int index = hash1(key);
        int step = hash2(key);

        int i = 0;
        int newIndex;

        while (i < SIZE) {
            newIndex = (index + i * step) % SIZE;

            if (keys[newIndex] == key) {
                cout << "Client found: " << names[newIndex] 
                     << " (Phone No: " << keys[newIndex] << ")\n";
                return;
            }

            // Stop if an empty slot found (key not present)
            if (keys[newIndex] == -1) {
                break;
            }

            i++;
        }

        cout << "Client not found!\n";
    }

    // Display all records
    void display() {
        cout << "\n--- Hash Table ---\n";
        for (int i = 0; i < SIZE; i++) {
            if (keys[i] != -1)
                cout << i << " --> " << names[i] << " (" << keys[i] << ")\n";
            else
                cout << i << " --> [empty]\n";
        }
    }
};

int main() {
    HashTable ht;
    int choice;
    long long key;
    string name;

    do {
        cout << "\n--- Telephone Book Menu ---\n";
        cout << "1. Insert client\n2. Search client\n3. Display hash table\n4. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "Enter client name: ";
            cin >> name;
            cout << "Enter telephone number: ";
            cin >> key;
            ht.insert(key, name);
            break;

        case 2:
            cout << "Enter telephone number to search: ";
            cin >> key;
            ht.search(key);
            break;

        case 3:
            ht.display();
            break;

        case 4:
            cout << "Exiting...\n";
            break;

        default:
            cout << "Invalid choice!\n";
        }
    } while (choice != 4);

    return 0;
}




You said:




I will send you problem statement on that basis you give me the algoritm for that problem statement
ChatGPT said:
Perfect ğŸ‘
Please send me the problem statement, and Iâ€™ll write a clear, step-by-step algorithm for it (in an easy and detailed way).

You said:
A-1  
  
Write menu based program-  
  
a) Write a program to store roll numbers of students in an array who attended a training program in random order. Write a function for searching whether a particular student attended a training program or not, using Linear search.  
  
b) Write a program to store roll numbers of student array who attended training programs in sorted order. Write a function for searching whether a particular student attended a training program or not, using Binary search.
ChatGPT said:
Great ğŸ‘
Letâ€™s write two separate algorithms â€” one for Linear Search (unsorted array) and one for Binary Search (sorted array) â€” exactly matching your problem statement A-1.

ğŸ§© Problem A-1 (Algorithm)
(a) Linear Search (Unsorted Array)
Aim:
To check whether a student (given by roll number) attended a training program or not using Linear Search.

Algorithm:
Start

Initialize an array roll_no[] to store roll numbers of students (in random order).

Input the number of students n.

Read n roll numbers and store them in roll_no[].

Input the roll number key (the student roll number to search).

Set a flag variable found = false.

Repeat steps for each element i from 0 to n-1:

If roll_no[i] == key then
â†’ Set found = true
â†’ Print â€œStudent attended the training program.â€
â†’ Stop the search (break).

If found == false, then
â†’ Print â€œStudent did not attend the training program.â€

Stop

Example:
Input:
Roll numbers: [105, 101, 110, 102]
Key = 110

Output:
Student attended the training program.
(b) Binary Search (Sorted Array)
Aim:
To check whether a student attended the training program using Binary Search (sorted roll numbers).

Algorithm:
Start

Initialize an array roll_no[] to store roll numbers of students (in sorted order).

Input the number of students n.

Read n sorted roll numbers and store them in roll_no[].

Input the roll number key to search.

Set

low = 0

high = n - 1

found = false

Repeat while low <= high:

Calculate mid = (low + high) / 2

If roll_no[mid] == key then
â†’ Set found = true
â†’ Print â€œStudent attended the training program.â€
â†’ Stop the search

Else if roll_no[mid] < key then
â†’ low = mid + 1

Else
â†’ high = mid - 1

If found == false,
â†’ Print â€œStudent did not attend the training program.â€

Stop

Example:
Input:
Roll numbers: [101, 102, 105, 110]
Key = 105

Output:
Student attended the training program.
Would you like me to also give the C++ code for both (a) and (b) based on these algorithms?

You said:


A-2a

Write a program to store the first year percentage of students in an array. Write function for sorting array of floating point numbers in ascending order using Selection Sort and display top five scores

ChatGPT said:
Perfect ğŸ‘
Letâ€™s write the step-by-step algorithm for your A-2a problem â€” which is about Selection Sort on floating-point numbers and displaying top five scores.

ğŸ§© Problem A-2a (Algorithm)
Aim:
To store the first-year percentages of students in an array, sort them in ascending order using Selection Sort, and display the top five scores.

Algorithm:
Start

Input the total number of students n.

Declare an array percent[n] to store the percentages (floating-point values).

Read n percentages from the user and store them in the array percent[].

Selection Sort Logic (Ascending Order):
Repeat for each index i from 0 to n-2:
a. Assume the smallest element is at index min_index = i.
b. For each index j from i+1 to n-1:

If percent[j] < percent[min_index], then
â†’ Set min_index = j.
c. Swap percent[i] and percent[min_index].

After all passes, the array percent[] will be sorted in ascending order.

Display Top Five Scores:
Print the message: â€œTop Five Scores Are:â€

If n >= 5 then

Display the last five elements of the array in descending order (highest first):
percent[n-1], percent[n-2], percent[n-3], percent[n-4], percent[n-5]

Else

Display all available elements in descending order.

Stop

Example:
Input:
Number of students = 7
Percentages = [78.5, 90.2, 67.8, 88.9, 95.4, 72.3, 81.0]

After Selection Sort (Ascending):
[67.8, 72.3, 78.5, 81.0, 88.9, 90.2, 95.4]

Top Five Scores:
95.4, 90.2, 88.9, 81.0, 78.5
Would you like me to now write the C++ program for this algorithm (A-2a) too?

You said:
A-2b

Write a program to store the first year percentage of students in an array. Write function for sorting array of floating point numbers in ascending order using Bubble sort and display top five scores

ChatGPT said:
Perfect ğŸ‘
Letâ€™s write the step-by-step algorithm for your A-2b problem â€” which is about Bubble Sort on floating-point numbers and showing the top five scores.

ğŸ§© Problem A-2b (Algorithm)
Aim:
To store the first-year percentages of students in an array, sort them in ascending order using Bubble Sort, and display the top five scores.

Algorithm:
Start

Input the total number of students n.

Declare an array percent[n] to store the percentages (floating-point numbers).

Read n percentage values from the user and store them in percent[].

Bubble Sort Logic (Ascending Order):
Repeat for each pass i from 0 to n-2:

For each j from 0 to n-i-2:

If percent[j] > percent[j+1], then
â†’ Swap the two values percent[j] and percent[j+1].

After all passes, the array percent[] will be sorted in ascending order.

Display Top Five Scores:
Print the message: â€œTop Five Scores Are:â€

If n >= 5 then

Display the last five elements in descending order (highest first):
percent[n-1], percent[n-2], percent[n-3], percent[n-4], percent[n-5]

Else

Display all available elements in descending order.

Stop

Example:
Input:
Number of students = 6
Percentages = [85.6, 90.3, 77.5, 88.0, 95.2, 80.4]

After Bubble Sort (Ascending):
[77.5, 80.4, 85.6, 88.0, 90.3, 95.2]

Top Five Scores:
95.2, 90.3, 88.0, 85.6, 80.4
Would you like me to now write the C++ program for this algorithm (A-2b)?

You said:
A-3a

Consider the telephone book database of N clients. Make use of a hash table implementation to quickly look up a client's telephone number. Make use of linear probing collision handling techniques.

ChatGPT said:
Excellent ğŸ‘
Letâ€™s write a clear and complete algorithm for Problem A-3a, which involves Hash Table implementation using Linear Probing to store and search client telephone numbers efficiently.

ğŸ§© Problem A-3a (Algorithm)
Aim:
To design a telephone book database using a hash table that allows quick lookup of a clientâ€™s telephone number using Linear Probing for collision handling.

Concept Overview:
A hash table stores data in keyâ€“value pairs.

Key â†’ Telephone number (or clientâ€™s unique ID).

Value â†’ Client name (or any other info).

The hash function finds the index for a key.

If a collision occurs (same index already occupied), Linear Probing searches for the next empty location.

Algorithm:
Start

Input the total number of clients N.

Initialize a hash table of size SIZE (preferably greater than or equal to N).

Set all hash table positions as empty (e.g., key = -1 or name = " ").

Insertion Operation:
For each client:

Input telephone number key and client name name.

Compute hash index:
index = key % SIZE

If that position is empty:
â†’ Store key and name at index.

Else (collision occurs):
â†’ Use Linear Probing:

Increment index: index = (index + 1) % SIZE

Repeat until an empty position is found.

Insert the key and name there.

Search Operation:
Input the telephone number key to search.

Compute hash index:
index = key % SIZE

Repeat while that position is not empty:

If hashTable[index].key == key then
â†’ Print â€œClient Foundâ€ and display name.
â†’ Stop.

Else
â†’ Move to next index: index = (index + 1) % SIZE

If an empty position is reached without finding the key:
â†’ Print â€œClient not found.â€

Display Operation (Optional):
Traverse the hash table and print all non-empty entries (index, name, telephone number).

Stop
Example:
Hash Table Size = 10
Data:
(101, "Amit")
(111, "Neha")
(121, "Ravi")

Insertion:
index(101) = 101 % 10 = 1 â†’ store at 1
index(111) = 111 % 10 = 1 â†’ collision â†’ next empty = 2 â†’ store at 2
index(121) = 121 % 10 = 1 â†’ collision â†’ next empty = 3 â†’ store at 3

Search:
key = 111 â†’ index = 1 â†’ not match â†’ next index = 2 â†’ found â†’ â€œClient Found: Nehaâ€
Would you like me to also write the C++ program for this algorithm (A-3a)?

You said:
A-3b

Consider the telephone book database of N clients. Make use of a hash table implementation to quickly look up a client's telephone number. Make use of double hashing collision handling techniques.

ChatGPT said:
Perfect ğŸ‘
Letâ€™s now write the step-by-step algorithm for Problem A-3b, which uses a hash table with double hashing to store and look up client telephone numbers efficiently.

ğŸ§© Problem A-3b (Algorithm)
Aim:
To design a telephone book database using a hash table for quick lookup of a clientâ€™s telephone number, using Double Hashing for collision resolution.

Concept Overview:
A hash table stores keyâ€“value pairs (like phone number â†’ client name).

When a collision occurs (two keys hash to the same index), Double Hashing computes a second hash value to determine how far to move (the step size) to find the next available position.

This reduces clustering compared to linear probing.

Algorithm:
Start

Input the total number of clients N.

Initialize a hash table of size SIZE (â‰¥ N).

Set all hash table entries as empty (e.g., key = -1, name = â€œ â€).

Define Hash Functions:
Define:

Primary hash:
h1(key) = key % SIZE

Secondary hash:
h2(key) = 7 - (key % 7)
(Choose 7 smaller than SIZE and prime to SIZE)

Insertion Operation:
For each client:

Input telephone number key and client name name.

Compute the initial index:
index = h1(key)

If that position is empty:
â†’ Store the record (key, name) at index.

Else (collision occurs):

Compute the step size using h2(key).

Repeat until an empty position is found:
index = (index + h2(key)) % SIZE

Store the record at that position.

Search Operation:
Input the telephone number key to search.

Compute:

index = h1(key)

step = h2(key)

Repeat while that position is not empty:

If hashTable[index].key == key:
â†’ Print â€œClient Foundâ€ and display name.
â†’ Stop.

Else:
â†’ Move to next index:
index = (index + step) % SIZE

If an empty position is reached without finding the key:
â†’ Print â€œClient not found.â€

Display Operation (Optional):
Traverse the hash table and print all non-empty entries with index, client name, and telephone number.

Stop
